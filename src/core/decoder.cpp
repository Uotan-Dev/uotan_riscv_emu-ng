/*
 * Copyright 2025 Nuo Shen, Nanjing University
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <utility>

#include "common/bit.hpp"
#include "core/decoder.hpp"
#include "core/execute.hpp" // IWYU pragma: keep

namespace uemu::core {

struct PatternData {
    uint64_t key = 0;
    uint64_t mask = 0;
    uint64_t shift = 0;
};

static inline constexpr PatternData parse_pattern(std::string_view pattern) {
    PatternData d{};
    uint64_t __key = 0, __mask = 0, __shift = 0;

    for (char c : pattern) {
        if (c != ' ') {
            __key = (__key << 1) | (c == '1' ? 1 : 0);
            __mask = (__mask << 1) | (c == '?' ? 0 : 1);
            __shift = (c == '?' ? __shift + 1 : 0);
        }
    }

    d.key = __key >> __shift;
    d.mask = __mask >> __shift;
    d.shift = __shift;

    return d;
}

#define INSTPAT(pattern, name, itype)                                          \
    do {                                                                       \
        constexpr auto pat = parse_pattern(pattern);                           \
        if (((static_cast<uint64_t>(insn)) >> pat.shift & pat.mask) ==         \
            pat.key) {                                                         \
            s.iname = Iname::rv_##name;                                        \
            s.type = Itype::TYPE_##itype;                                      \
            s.exec = exec_##name;                                              \
            Decoder::decode_operand(s);                                        \
            return s;                                                          \
        }                                                                      \
    } while (0)

DecodedInsn Decoder::decode(uint32_t insn, Ilen len, addr_t pc) {
    DecodedInsn s;

    if (len == Ilen::Compressed)
        insn &= 0xFFFF;

    s.insn = insn;
    s.len = len;
    s.pc = pc;

    // RV64I instructions
    INSTPAT("0000000 ????? ????? 000 ????? 01100 11", add, R);
    INSTPAT("??????? ????? ????? 000 ????? 00100 11", addi, I);
    INSTPAT("??????? ????? ????? 000 ????? 00110 11", addiw, I);
    INSTPAT("0000000 ????? ????? 000 ????? 01110 11", addw, R);
    INSTPAT("0000000 ????? ????? 111 ????? 01100 11", and, R);
    INSTPAT("??????? ????? ????? 111 ????? 00100 11", andi, I);
    INSTPAT("??????? ????? ????? ??? ????? 00101 11", auipc, U);
    INSTPAT("??????? ????? ????? 000 ????? 11000 11", beq, B);
    INSTPAT("??????? ????? ????? 101 ????? 11000 11", bge, B);
    INSTPAT("??????? ????? ????? 111 ????? 11000 11", bgeu, B);
    INSTPAT("??????? ????? ????? 100 ????? 11000 11", blt, B);
    INSTPAT("??????? ????? ????? 110 ????? 11000 11", bltu, B);
    INSTPAT("??????? ????? ????? 001 ????? 11000 11", bne, B);
    INSTPAT("0000??? ????? 00000 000 00000 00011 11", fence, I);
    INSTPAT("0000000 00000 00000 001 00000 00011 11", fence_i, I);
    INSTPAT("??????? ????? ????? ??? ????? 11011 11", jal, J);
    INSTPAT("??????? ????? ????? 000 ????? 11001 11", jalr, I);
    INSTPAT("??????? ????? ????? 000 ????? 00000 11", lb, I);
    INSTPAT("??????? ????? ????? 100 ????? 00000 11", lbu, I);
    INSTPAT("??????? ????? ????? 011 ????? 00000 11", ld, I);
    INSTPAT("??????? ????? ????? 001 ????? 00000 11", lh, I);
    INSTPAT("??????? ????? ????? 101 ????? 00000 11", lhu, I);
    INSTPAT("??????? ????? ????? ??? ????? 01101 11", lui, U);
    INSTPAT("??????? ????? ????? 010 ????? 00000 11", lw, I);
    INSTPAT("??????? ????? ????? 110 ????? 00000 11", lwu, I);
    INSTPAT("0000000 ????? ????? 110 ????? 01100 11", or, R);
    INSTPAT("??????? ????? ????? 110 ????? 00100 11", ori, I);
    INSTPAT("??????? ????? ????? 000 ????? 01000 11", sb, S);
    INSTPAT("??????? ????? ????? 011 ????? 01000 11", sd, S);
    INSTPAT("??????? ????? ????? 001 ????? 01000 11", sh, S);
    INSTPAT("0000000 ????? ????? 001 ????? 01100 11", sll, R);
    INSTPAT("000000? ????? ????? 001 ????? 00100 11", slli, I);
    INSTPAT("0000000 ????? ????? 001 ????? 00110 11", slliw, I);
    INSTPAT("0000000 ????? ????? 001 ????? 01110 11", sllw, R);
    INSTPAT("0000000 ????? ????? 010 ????? 01100 11", slt, R);
    INSTPAT("??????? ????? ????? 010 ????? 00100 11", slti, I);
    INSTPAT("??????? ????? ????? 011 ????? 00100 11", sltiu, I);
    INSTPAT("0000000 ????? ????? 011 ????? 01100 11", sltu, R);
    INSTPAT("0100000 ????? ????? 101 ????? 01100 11", sra, R);
    INSTPAT("010000? ????? ????? 101 ????? 00100 11", srai, I);
    INSTPAT("0100000 ????? ????? 101 ????? 00110 11", sraiw, I);
    INSTPAT("0100000 ????? ????? 101 ????? 01110 11", sraw, R);
    INSTPAT("0000000 ????? ????? 101 ????? 01100 11", srl, R);
    INSTPAT("000000? ????? ????? 101 ????? 00100 11", srli, I);
    INSTPAT("0000000 ????? ????? 101 ????? 00110 11", srliw, I);
    INSTPAT("0000000 ????? ????? 101 ????? 01110 11", srlw, R);
    INSTPAT("0100000 ????? ????? 000 ????? 01100 11", sub, R);
    INSTPAT("0100000 ????? ????? 000 ????? 01110 11", subw, R);
    INSTPAT("??????? ????? ????? 010 ????? 01000 11", sw, S);
    INSTPAT("0000000 ????? ????? 100 ????? 01100 11", xor, R);
    INSTPAT("??????? ????? ????? 100 ????? 00100 11", xori, I);
    INSTPAT("??????? ????? ????? 011 ????? 11100 11", csrrc, I);
    INSTPAT("??????? ????? ????? 111 ????? 11100 11", csrrci, I);
    INSTPAT("??????? ????? ????? 010 ????? 11100 11", csrrs, I);
    INSTPAT("??????? ????? ????? 110 ????? 11100 11", csrrsi, I);
    INSTPAT("??????? ????? ????? 001 ????? 11100 11", csrrw, I);
    INSTPAT("??????? ????? ????? 101 ????? 11100 11", csrrwi, I);
    INSTPAT("0000000 00001 00000 000 00000 11100 11", ebreak, N);
    INSTPAT("0000000 00000 00000 000 00000 11100 11", ecall, N);
    INSTPAT("0011000 00010 00000 000 00000 11100 11", mret, N);
    INSTPAT("0001001 ????? ????? 000 00000 11100 11", sfence_vma, R);
    INSTPAT("0001000 00010 00000 000 00000 11100 11", sret, N);
    INSTPAT("0001000 00101 00000 000 00000 11100 11", wfi, N);

    // RV64M instructions
    INSTPAT("0000001 ????? ????? 100 ????? 01100 11", div, R);
    INSTPAT("0000001 ????? ????? 101 ????? 01100 11", divu, R);
    INSTPAT("0000001 ????? ????? 101 ????? 01110 11", divuw, R);
    INSTPAT("0000001 ????? ????? 100 ????? 01110 11", divw, R);
    INSTPAT("0000001 ????? ????? 000 ????? 01100 11", mul, R);
    INSTPAT("0000001 ????? ????? 001 ????? 01100 11", mulh, R);
    INSTPAT("0000001 ????? ????? 010 ????? 01100 11", mulhsu, R);
    INSTPAT("0000001 ????? ????? 011 ????? 01100 11", mulhu, R);
    INSTPAT("0000001 ????? ????? 000 ????? 01110 11", mulw, R);
    INSTPAT("0000001 ????? ????? 110 ????? 01100 11", rem, R);
    INSTPAT("0000001 ????? ????? 111 ????? 01100 11", remu, R);
    INSTPAT("0000001 ????? ????? 111 ????? 01110 11", remuw, R);
    INSTPAT("0000001 ????? ????? 110 ????? 01110 11", remw, R);

    // Invalid instructions
    INSTPAT("??????? ????? ????? ??? ????? ????? ??", inv, N);

    std::unreachable();
}

void Decoder::decode_operand(DecodedInsn& s) {
    s.rs1 = bits(s.insn, 19, 15);
    s.rs2 = bits(s.insn, 24, 20);
    s.rs3 = bits(s.insn, 31, 27);
    s.rd = bits(s.insn, 11, 7);
    switch (s.type) {
        case Itype::TYPE_I: s.imm = sext(bits(s.insn, 31, 20), 12); break;
        case Itype::TYPE_U: s.imm = sext(bits(s.insn, 31, 12), 20) << 12; break;
        case Itype::TYPE_S:
            s.imm = (sext(bits(s.insn, 31, 25), 7) << 5) | bits(s.insn, 11, 7);
            break;
        case Itype::TYPE_J:
            s.imm =
                sext(bits(s.insn, 31, 31) << 20 | bits(s.insn, 19, 12) << 12 |
                         bits(s.insn, 20, 20) << 11 | bits(s.insn, 30, 21) << 1,
                     21);
            break;
        case Itype::TYPE_B:
            s.imm =
                sext(bits(s.insn, 31, 31) << 12 | bits(s.insn, 7, 7) << 11 |
                         bits(s.insn, 30, 25) << 5 | bits(s.insn, 11, 8) << 1,
                     13);
            break;
        default: break;
    }
}

} // namespace uemu::core
