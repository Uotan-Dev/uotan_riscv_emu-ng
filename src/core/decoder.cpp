/*
 * Copyright 2025-2026 Nuo Shen, Nanjing University
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <utility>

#include "common/bit.hpp"
#include "core/decoder.hpp"
#include "core/execute.hpp" // IWYU pragma: keep

namespace uemu::core {

struct PatternData {
    uint64_t key = 0;
    uint64_t mask = 0;
    uint64_t shift = 0;
};

static inline constexpr PatternData parse_pattern(std::string_view pattern) {
    PatternData d{};
    uint64_t __key = 0, __mask = 0, __shift = 0;

    for (char c : pattern) {
        if (c != ' ') {
            __key = (__key << 1) | (c == '1' ? 1 : 0);
            __mask = (__mask << 1) | (c == '?' ? 0 : 1);
            __shift = (c == '?' ? __shift + 1 : 0);
        }
    }

    d.key = __key >> __shift;
    d.mask = __mask >> __shift;
    d.shift = __shift;

    return d;
}

#define INSTPAT(pattern, name, itype)                                          \
    do {                                                                       \
        constexpr auto pat = parse_pattern(pattern);                           \
        if (((static_cast<uint64_t>(insn)) >> pat.shift & pat.mask) ==         \
            pat.key) {                                                         \
            s.iname = Iname::rv_##name;                                        \
            s.type = Itype::TYPE_##itype;                                      \
            s.exec = exec_##name;                                              \
            Decoder::decode_operand(s);                                        \
            return s;                                                          \
        }                                                                      \
    } while (0)

DecodedInsn Decoder::decode(uint32_t insn, Ilen len, addr_t pc) {
    DecodedInsn s;

    if (len == Ilen::Compressed)
        insn &= 0xFFFF;

    s.insn = insn;
    s.len = len;
    s.pc = pc;

    // RV64I instructions
    INSTPAT("0000000 ????? ????? 000 ????? 01100 11", add, R);
    INSTPAT("??????? ????? ????? 000 ????? 00100 11", addi, I);
    INSTPAT("??????? ????? ????? 000 ????? 00110 11", addiw, I);
    INSTPAT("0000000 ????? ????? 000 ????? 01110 11", addw, R);
    INSTPAT("0000000 ????? ????? 111 ????? 01100 11", and, R);
    INSTPAT("??????? ????? ????? 111 ????? 00100 11", andi, I);
    INSTPAT("??????? ????? ????? ??? ????? 00101 11", auipc, U);
    INSTPAT("??????? ????? ????? 000 ????? 11000 11", beq, B);
    INSTPAT("??????? ????? ????? 101 ????? 11000 11", bge, B);
    INSTPAT("??????? ????? ????? 111 ????? 11000 11", bgeu, B);
    INSTPAT("??????? ????? ????? 100 ????? 11000 11", blt, B);
    INSTPAT("??????? ????? ????? 110 ????? 11000 11", bltu, B);
    INSTPAT("??????? ????? ????? 001 ????? 11000 11", bne, B);
    INSTPAT("0000??? ????? 00000 000 00000 00011 11", fence, I);
    INSTPAT("0000000 00000 00000 001 00000 00011 11", fence_i, I);
    INSTPAT("??????? ????? ????? ??? ????? 11011 11", jal, J);
    INSTPAT("??????? ????? ????? 000 ????? 11001 11", jalr, I);
    INSTPAT("??????? ????? ????? 000 ????? 00000 11", lb, I);
    INSTPAT("??????? ????? ????? 100 ????? 00000 11", lbu, I);
    INSTPAT("??????? ????? ????? 011 ????? 00000 11", ld, I);
    INSTPAT("??????? ????? ????? 001 ????? 00000 11", lh, I);
    INSTPAT("??????? ????? ????? 101 ????? 00000 11", lhu, I);
    INSTPAT("??????? ????? ????? ??? ????? 01101 11", lui, U);
    INSTPAT("??????? ????? ????? 010 ????? 00000 11", lw, I);
    INSTPAT("??????? ????? ????? 110 ????? 00000 11", lwu, I);
    INSTPAT("0000000 ????? ????? 110 ????? 01100 11", or, R);
    INSTPAT("??????? ????? ????? 110 ????? 00100 11", ori, I);
    INSTPAT("??????? ????? ????? 000 ????? 01000 11", sb, S);
    INSTPAT("??????? ????? ????? 011 ????? 01000 11", sd, S);
    INSTPAT("??????? ????? ????? 001 ????? 01000 11", sh, S);
    INSTPAT("0000000 ????? ????? 001 ????? 01100 11", sll, R);
    INSTPAT("000000? ????? ????? 001 ????? 00100 11", slli, I);
    INSTPAT("0000000 ????? ????? 001 ????? 00110 11", slliw, I);
    INSTPAT("0000000 ????? ????? 001 ????? 01110 11", sllw, R);
    INSTPAT("0000000 ????? ????? 010 ????? 01100 11", slt, R);
    INSTPAT("??????? ????? ????? 010 ????? 00100 11", slti, I);
    INSTPAT("??????? ????? ????? 011 ????? 00100 11", sltiu, I);
    INSTPAT("0000000 ????? ????? 011 ????? 01100 11", sltu, R);
    INSTPAT("0100000 ????? ????? 101 ????? 01100 11", sra, R);
    INSTPAT("010000? ????? ????? 101 ????? 00100 11", srai, I);
    INSTPAT("0100000 ????? ????? 101 ????? 00110 11", sraiw, I);
    INSTPAT("0100000 ????? ????? 101 ????? 01110 11", sraw, R);
    INSTPAT("0000000 ????? ????? 101 ????? 01100 11", srl, R);
    INSTPAT("000000? ????? ????? 101 ????? 00100 11", srli, I);
    INSTPAT("0000000 ????? ????? 101 ????? 00110 11", srliw, I);
    INSTPAT("0000000 ????? ????? 101 ????? 01110 11", srlw, R);
    INSTPAT("0100000 ????? ????? 000 ????? 01100 11", sub, R);
    INSTPAT("0100000 ????? ????? 000 ????? 01110 11", subw, R);
    INSTPAT("??????? ????? ????? 010 ????? 01000 11", sw, S);
    INSTPAT("0000000 ????? ????? 100 ????? 01100 11", xor, R);
    INSTPAT("??????? ????? ????? 100 ????? 00100 11", xori, I);
    INSTPAT("??????? ????? ????? 011 ????? 11100 11", csrrc, I);
    INSTPAT("??????? ????? ????? 111 ????? 11100 11", csrrci, I);
    INSTPAT("??????? ????? ????? 010 ????? 11100 11", csrrs, I);
    INSTPAT("??????? ????? ????? 110 ????? 11100 11", csrrsi, I);
    INSTPAT("??????? ????? ????? 001 ????? 11100 11", csrrw, I);
    INSTPAT("??????? ????? ????? 101 ????? 11100 11", csrrwi, I);
    INSTPAT("0000000 00001 00000 000 00000 11100 11", ebreak, N);
    INSTPAT("0000000 00000 00000 000 00000 11100 11", ecall, N);
    INSTPAT("0011000 00010 00000 000 00000 11100 11", mret, N);
    INSTPAT("0001001 ????? ????? 000 00000 11100 11", sfence_vma, R);
    INSTPAT("0001000 00010 00000 000 00000 11100 11", sret, N);
    INSTPAT("0001000 00101 00000 000 00000 11100 11", wfi, N);

    // RV64M instructions
    INSTPAT("0000001 ????? ????? 100 ????? 01100 11", div, R);
    INSTPAT("0000001 ????? ????? 101 ????? 01100 11", divu, R);
    INSTPAT("0000001 ????? ????? 101 ????? 01110 11", divuw, R);
    INSTPAT("0000001 ????? ????? 100 ????? 01110 11", divw, R);
    INSTPAT("0000001 ????? ????? 000 ????? 01100 11", mul, R);
    INSTPAT("0000001 ????? ????? 001 ????? 01100 11", mulh, R);
    INSTPAT("0000001 ????? ????? 010 ????? 01100 11", mulhsu, R);
    INSTPAT("0000001 ????? ????? 011 ????? 01100 11", mulhu, R);
    INSTPAT("0000001 ????? ????? 000 ????? 01110 11", mulw, R);
    INSTPAT("0000001 ????? ????? 110 ????? 01100 11", rem, R);
    INSTPAT("0000001 ????? ????? 111 ????? 01100 11", remu, R);
    INSTPAT("0000001 ????? ????? 111 ????? 01110 11", remuw, R);
    INSTPAT("0000001 ????? ????? 110 ????? 01110 11", remw, R);

    // RV64A instructions
    INSTPAT("00010?? 00000 ????? 011 ????? 01011 11", lr_d, R);
    INSTPAT("00010?? 00000 ????? 010 ????? 01011 11", lr_w, R);
    INSTPAT("00011?? ????? ????? 011 ????? 01011 11", sc_d, R);
    INSTPAT("00011?? ????? ????? 010 ????? 01011 11", sc_w, R);
    INSTPAT("00000?? ????? ????? 011 ????? 01011 11", amoadd_d, R);
    INSTPAT("00000?? ????? ????? 010 ????? 01011 11", amoadd_w, R);
    INSTPAT("01100?? ????? ????? 011 ????? 01011 11", amoand_d, R);
    INSTPAT("01100?? ????? ????? 010 ????? 01011 11", amoand_w, R);
    INSTPAT("01000?? ????? ????? 011 ????? 01011 11", amoor_d, R);
    INSTPAT("01000?? ????? ????? 010 ????? 01011 11", amoor_w, R);
    INSTPAT("00100?? ????? ????? 011 ????? 01011 11", amoxor_d, R);
    INSTPAT("00100?? ????? ????? 010 ????? 01011 11", amoxor_w, R);
    INSTPAT("10100?? ????? ????? 011 ????? 01011 11", amomax_d, R);
    INSTPAT("10100?? ????? ????? 010 ????? 01011 11", amomax_w, R);
    INSTPAT("11100?? ????? ????? 011 ????? 01011 11", amomaxu_d, R);
    INSTPAT("11100?? ????? ????? 010 ????? 01011 11", amomaxu_w, R);
    INSTPAT("10000?? ????? ????? 011 ????? 01011 11", amomin_d, R);
    INSTPAT("10000?? ????? ????? 010 ????? 01011 11", amomin_w, R);
    INSTPAT("11000?? ????? ????? 011 ????? 01011 11", amominu_d, R);
    INSTPAT("11000?? ????? ????? 010 ????? 01011 11", amominu_w, R);
    INSTPAT("00001?? ????? ????? 011 ????? 01011 11", amoswap_d, R);
    INSTPAT("00001?? ????? ????? 010 ????? 01011 11", amoswap_w, R);

    // RV64F instructions
    INSTPAT("??????? ????? ????? 010 ????? 00001 11", flw, I);
    INSTPAT("??????? ????? ????? 010 ????? 01001 11", fsw, S);
    INSTPAT("0000000 ????? ????? ??? ????? 10100 11", fadd_s, R);
    INSTPAT("0000100 ????? ????? ??? ????? 10100 11", fsub_s, R);
    INSTPAT("0001000 ????? ????? ??? ????? 10100 11", fmul_s, R);
    INSTPAT("0001100 ????? ????? ??? ????? 10100 11", fdiv_s, R);
    INSTPAT("0101100 00000 ????? ??? ????? 10100 11", fsqrt_s, R);
    INSTPAT("0010000 ????? ????? 000 ????? 10100 11", fsgnj_s, R);
    INSTPAT("0010000 ????? ????? 001 ????? 10100 11", fsgnjn_s, R);
    INSTPAT("0010000 ????? ????? 010 ????? 10100 11", fsgnjx_s, R);
    INSTPAT("0010100 ????? ????? 000 ????? 10100 11", fmin_s, R);
    INSTPAT("0010100 ????? ????? 001 ????? 10100 11", fmax_s, R);
    INSTPAT("1100000 00000 ????? ??? ????? 10100 11", fcvt_w_s, R);
    INSTPAT("1100000 00001 ????? ??? ????? 10100 11", fcvt_wu_s, R);
    INSTPAT("1100000 00010 ????? ??? ????? 10100 11", fcvt_l_s, R);
    INSTPAT("1100000 00011 ????? ??? ????? 10100 11", fcvt_lu_s, R);
    INSTPAT("1101000 00000 ????? ??? ????? 10100 11", fcvt_s_w, R);
    INSTPAT("1101000 00001 ????? ??? ????? 10100 11", fcvt_s_wu, R);
    INSTPAT("1101000 00010 ????? ??? ????? 10100 11", fcvt_s_l, R);
    INSTPAT("1101000 00011 ????? ??? ????? 10100 11", fcvt_s_lu, R);
    INSTPAT("1110000 00000 ????? 000 ????? 10100 11", fmv_x_w, R);
    INSTPAT("1111000 00000 ????? 000 ????? 10100 11", fmv_w_x, R);
    INSTPAT("1110000 00000 ????? 001 ????? 10100 11", fclass_s, R);
    INSTPAT("1010000 ????? ????? 010 ????? 10100 11", feq_s, R);
    INSTPAT("1010000 ????? ????? 001 ????? 10100 11", flt_s, R);
    INSTPAT("1010000 ????? ????? 000 ????? 10100 11", fle_s, R);
    INSTPAT("?????00 ????? ????? ??? ????? 10000 11", fmadd_s, R4);
    INSTPAT("?????00 ????? ????? ??? ????? 10001 11", fmsub_s, R4);
    INSTPAT("?????00 ????? ????? ??? ????? 10010 11", fnmsub_s, R4);
    INSTPAT("?????00 ????? ????? ??? ????? 10011 11", fnmadd_s, R4);

    // RV64D instructions
    INSTPAT("??????? ????? ????? 011 ????? 00001 11", fld, I);
    INSTPAT("??????? ????? ????? 011 ????? 01001 11", fsd, S);
    INSTPAT("0000001 ????? ????? ??? ????? 10100 11", fadd_d, R);
    INSTPAT("0000101 ????? ????? ??? ????? 10100 11", fsub_d, R);
    INSTPAT("0001001 ????? ????? ??? ????? 10100 11", fmul_d, R);
    INSTPAT("0001101 ????? ????? ??? ????? 10100 11", fdiv_d, R);
    INSTPAT("0101101 00000 ????? ??? ????? 10100 11", fsqrt_d, R);
    INSTPAT("0010001 ????? ????? 000 ????? 10100 11", fsgnj_d, R);
    INSTPAT("0010001 ????? ????? 001 ????? 10100 11", fsgnjn_d, R);
    INSTPAT("0010001 ????? ????? 010 ????? 10100 11", fsgnjx_d, R);
    INSTPAT("0010101 ????? ????? 000 ????? 10100 11", fmin_d, R);
    INSTPAT("0010101 ????? ????? 001 ????? 10100 11", fmax_d, R);
    INSTPAT("1100001 00000 ????? ??? ????? 10100 11", fcvt_w_d, R);
    INSTPAT("1100001 00001 ????? ??? ????? 10100 11", fcvt_wu_d, R);
    INSTPAT("1100001 00010 ????? ??? ????? 10100 11", fcvt_l_d, R);
    INSTPAT("1100001 00011 ????? ??? ????? 10100 11", fcvt_lu_d, R);
    INSTPAT("1101001 00000 ????? ??? ????? 10100 11", fcvt_d_w, R);
    INSTPAT("1101001 00001 ????? ??? ????? 10100 11", fcvt_d_wu, R);
    INSTPAT("1101001 00010 ????? ??? ????? 10100 11", fcvt_d_l, R);
    INSTPAT("1101001 00011 ????? ??? ????? 10100 11", fcvt_d_lu, R);
    INSTPAT("0100000 00001 ????? ??? ????? 10100 11", fcvt_s_d, R);
    INSTPAT("0100001 00000 ????? ??? ????? 10100 11", fcvt_d_s, R);
    INSTPAT("1110001 00000 ????? 000 ????? 10100 11", fmv_x_d, R);
    INSTPAT("1111001 00000 ????? 000 ????? 10100 11", fmv_d_x, R);
    INSTPAT("1110001 00000 ????? 001 ????? 10100 11", fclass_d, R);
    INSTPAT("1010001 ????? ????? 010 ????? 10100 11", feq_d, R);
    INSTPAT("1010001 ????? ????? 001 ????? 10100 11", flt_d, R);
    INSTPAT("1010001 ????? ????? 000 ????? 10100 11", fle_d, R);
    INSTPAT("?????01 ????? ????? ??? ????? 10000 11", fmadd_d, R4);
    INSTPAT("?????01 ????? ????? ??? ????? 10001 11", fmsub_d, R4);
    INSTPAT("?????01 ????? ????? ??? ????? 10010 11", fnmsub_d, R4);
    INSTPAT("?????01 ????? ????? ??? ????? 10011 11", fnmadd_d, R4);

    // Invalid instructions
    INSTPAT("??????? ????? ????? ??? ????? ????? ??", inv, N);

    std::unreachable();
}

void Decoder::decode_operand(DecodedInsn& s) {
    s.rs1 = bits(s.insn, 19, 15);
    s.rs2 = bits(s.insn, 24, 20);
    s.rs3 = bits(s.insn, 31, 27);
    s.rd = bits(s.insn, 11, 7);
    switch (s.type) {
        case Itype::TYPE_I: s.imm = sext(bits(s.insn, 31, 20), 12); break;
        case Itype::TYPE_U: s.imm = sext(bits(s.insn, 31, 12), 20) << 12; break;
        case Itype::TYPE_S:
            s.imm = (sext(bits(s.insn, 31, 25), 7) << 5) | bits(s.insn, 11, 7);
            break;
        case Itype::TYPE_J:
            s.imm =
                sext(bits(s.insn, 31, 31) << 20 | bits(s.insn, 19, 12) << 12 |
                         bits(s.insn, 20, 20) << 11 | bits(s.insn, 30, 21) << 1,
                     21);
            break;
        case Itype::TYPE_B:
            s.imm =
                sext(bits(s.insn, 31, 31) << 12 | bits(s.insn, 7, 7) << 11 |
                         bits(s.insn, 30, 25) << 5 | bits(s.insn, 11, 8) << 1,
                     13);
            break;
        default: break;
    }
}

} // namespace uemu::core
