/*
 * Copyright 2025-2026 Nuo Shen, Nanjing University
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <string_view>
#include <utility>

#include "common/bit.hpp"
#include "core/decoder.hpp"
#include "core/execute.hpp" // IWYU pragma: keep
#include "core/hart.hpp"

namespace uemu::core {

struct PatternData {
    uint64_t key = 0;
    uint64_t mask = 0;
    uint64_t shift = 0;
};

static inline constexpr PatternData parse_pattern(std::string_view pattern) {
    PatternData d{};
    uint64_t __key = 0, __mask = 0, __shift = 0;

    for (char c : pattern) {
        if (c != ' ') {
            __key = (__key << 1) | (c == '1' ? 1 : 0);
            __mask = (__mask << 1) | (c == '?' ? 0 : 1);
            __shift = (c == '?' ? __shift + 1 : 0);
        }
    }

    d.key = __key >> __shift;
    d.mask = __mask >> __shift;
    d.shift = __shift;

    return d;
}

DecodedInsn Decoder::decode(uint32_t insn, Ilen len, addr_t pc) {
    DecodedInsn s;

    s.insn = insn;
    s.len = len;
    s.pc = pc;

    if (len == Ilen::Normal) {

#define INSTPAT(pattern, name, itype)                                          \
    do {                                                                       \
        constexpr auto pat = parse_pattern(pattern);                           \
        if (((static_cast<uint64_t>(insn)) >> pat.shift & pat.mask) ==         \
            pat.key) {                                                         \
            s.iname = Iname::rv_##name;                                        \
            s.type = Itype::itype;                                             \
            s.exec = exec_##name;                                              \
            Decoder::decode_operand_32(s);                                     \
            return s;                                                          \
        }                                                                      \
    } while (0)

        // RV64I instructions
        INSTPAT("0000000 ????? ????? 000 ????? 01100 11", add, R);
        INSTPAT("??????? ????? ????? 000 ????? 00100 11", addi, I);
        INSTPAT("??????? ????? ????? 000 ????? 00110 11", addiw, I);
        INSTPAT("0000000 ????? ????? 000 ????? 01110 11", addw, R);
        INSTPAT("0000000 ????? ????? 111 ????? 01100 11", and, R);
        INSTPAT("??????? ????? ????? 111 ????? 00100 11", andi, I);
        INSTPAT("??????? ????? ????? ??? ????? 00101 11", auipc, U);
        INSTPAT("??????? ????? ????? 000 ????? 11000 11", beq, B);
        INSTPAT("??????? ????? ????? 101 ????? 11000 11", bge, B);
        INSTPAT("??????? ????? ????? 111 ????? 11000 11", bgeu, B);
        INSTPAT("??????? ????? ????? 100 ????? 11000 11", blt, B);
        INSTPAT("??????? ????? ????? 110 ????? 11000 11", bltu, B);
        INSTPAT("??????? ????? ????? 001 ????? 11000 11", bne, B);
        INSTPAT("0000??? ????? 00000 000 00000 00011 11", fence, I);
        INSTPAT("0000000 00000 00000 001 00000 00011 11", fence_i, I);
        INSTPAT("??????? ????? ????? ??? ????? 11011 11", jal, J);
        INSTPAT("??????? ????? ????? 000 ????? 11001 11", jalr, I);
        INSTPAT("??????? ????? ????? 000 ????? 00000 11", lb, I);
        INSTPAT("??????? ????? ????? 100 ????? 00000 11", lbu, I);
        INSTPAT("??????? ????? ????? 011 ????? 00000 11", ld, I);
        INSTPAT("??????? ????? ????? 001 ????? 00000 11", lh, I);
        INSTPAT("??????? ????? ????? 101 ????? 00000 11", lhu, I);
        INSTPAT("??????? ????? ????? ??? ????? 01101 11", lui, U);
        INSTPAT("??????? ????? ????? 010 ????? 00000 11", lw, I);
        INSTPAT("??????? ????? ????? 110 ????? 00000 11", lwu, I);
        INSTPAT("0000000 ????? ????? 110 ????? 01100 11", or, R);
        INSTPAT("??????? ????? ????? 110 ????? 00100 11", ori, I);
        INSTPAT("??????? ????? ????? 000 ????? 01000 11", sb, S);
        INSTPAT("??????? ????? ????? 011 ????? 01000 11", sd, S);
        INSTPAT("??????? ????? ????? 001 ????? 01000 11", sh, S);
        INSTPAT("0000000 ????? ????? 001 ????? 01100 11", sll, R);
        INSTPAT("000000? ????? ????? 001 ????? 00100 11", slli, I);
        INSTPAT("0000000 ????? ????? 001 ????? 00110 11", slliw, I);
        INSTPAT("0000000 ????? ????? 001 ????? 01110 11", sllw, R);
        INSTPAT("0000000 ????? ????? 010 ????? 01100 11", slt, R);
        INSTPAT("??????? ????? ????? 010 ????? 00100 11", slti, I);
        INSTPAT("??????? ????? ????? 011 ????? 00100 11", sltiu, I);
        INSTPAT("0000000 ????? ????? 011 ????? 01100 11", sltu, R);
        INSTPAT("0100000 ????? ????? 101 ????? 01100 11", sra, R);
        INSTPAT("010000? ????? ????? 101 ????? 00100 11", srai, I);
        INSTPAT("0100000 ????? ????? 101 ????? 00110 11", sraiw, I);
        INSTPAT("0100000 ????? ????? 101 ????? 01110 11", sraw, R);
        INSTPAT("0000000 ????? ????? 101 ????? 01100 11", srl, R);
        INSTPAT("000000? ????? ????? 101 ????? 00100 11", srli, I);
        INSTPAT("0000000 ????? ????? 101 ????? 00110 11", srliw, I);
        INSTPAT("0000000 ????? ????? 101 ????? 01110 11", srlw, R);
        INSTPAT("0100000 ????? ????? 000 ????? 01100 11", sub, R);
        INSTPAT("0100000 ????? ????? 000 ????? 01110 11", subw, R);
        INSTPAT("??????? ????? ????? 010 ????? 01000 11", sw, S);
        INSTPAT("0000000 ????? ????? 100 ????? 01100 11", xor, R);
        INSTPAT("??????? ????? ????? 100 ????? 00100 11", xori, I);
        INSTPAT("??????? ????? ????? 011 ????? 11100 11", csrrc, I);
        INSTPAT("??????? ????? ????? 111 ????? 11100 11", csrrci, I);
        INSTPAT("??????? ????? ????? 010 ????? 11100 11", csrrs, I);
        INSTPAT("??????? ????? ????? 110 ????? 11100 11", csrrsi, I);
        INSTPAT("??????? ????? ????? 001 ????? 11100 11", csrrw, I);
        INSTPAT("??????? ????? ????? 101 ????? 11100 11", csrrwi, I);
        INSTPAT("0000000 00001 00000 000 00000 11100 11", ebreak, N);
        INSTPAT("0000000 00000 00000 000 00000 11100 11", ecall, N);
        INSTPAT("0011000 00010 00000 000 00000 11100 11", mret, N);
        INSTPAT("0001001 ????? ????? 000 00000 11100 11", sfence_vma, R);
        INSTPAT("0001000 00010 00000 000 00000 11100 11", sret, N);
        INSTPAT("0001000 00101 00000 000 00000 11100 11", wfi, N);

        // RV64M instructions
        INSTPAT("0000001 ????? ????? 100 ????? 01100 11", div, R);
        INSTPAT("0000001 ????? ????? 101 ????? 01100 11", divu, R);
        INSTPAT("0000001 ????? ????? 101 ????? 01110 11", divuw, R);
        INSTPAT("0000001 ????? ????? 100 ????? 01110 11", divw, R);
        INSTPAT("0000001 ????? ????? 000 ????? 01100 11", mul, R);
        INSTPAT("0000001 ????? ????? 001 ????? 01100 11", mulh, R);
        INSTPAT("0000001 ????? ????? 010 ????? 01100 11", mulhsu, R);
        INSTPAT("0000001 ????? ????? 011 ????? 01100 11", mulhu, R);
        INSTPAT("0000001 ????? ????? 000 ????? 01110 11", mulw, R);
        INSTPAT("0000001 ????? ????? 110 ????? 01100 11", rem, R);
        INSTPAT("0000001 ????? ????? 111 ????? 01100 11", remu, R);
        INSTPAT("0000001 ????? ????? 111 ????? 01110 11", remuw, R);
        INSTPAT("0000001 ????? ????? 110 ????? 01110 11", remw, R);

        // RV64A instructions
        INSTPAT("00010?? 00000 ????? 011 ????? 01011 11", lr_d, R);
        INSTPAT("00010?? 00000 ????? 010 ????? 01011 11", lr_w, R);
        INSTPAT("00011?? ????? ????? 011 ????? 01011 11", sc_d, R);
        INSTPAT("00011?? ????? ????? 010 ????? 01011 11", sc_w, R);
        INSTPAT("00000?? ????? ????? 011 ????? 01011 11", amoadd_d, R);
        INSTPAT("00000?? ????? ????? 010 ????? 01011 11", amoadd_w, R);
        INSTPAT("01100?? ????? ????? 011 ????? 01011 11", amoand_d, R);
        INSTPAT("01100?? ????? ????? 010 ????? 01011 11", amoand_w, R);
        INSTPAT("01000?? ????? ????? 011 ????? 01011 11", amoor_d, R);
        INSTPAT("01000?? ????? ????? 010 ????? 01011 11", amoor_w, R);
        INSTPAT("00100?? ????? ????? 011 ????? 01011 11", amoxor_d, R);
        INSTPAT("00100?? ????? ????? 010 ????? 01011 11", amoxor_w, R);
        INSTPAT("10100?? ????? ????? 011 ????? 01011 11", amomax_d, R);
        INSTPAT("10100?? ????? ????? 010 ????? 01011 11", amomax_w, R);
        INSTPAT("11100?? ????? ????? 011 ????? 01011 11", amomaxu_d, R);
        INSTPAT("11100?? ????? ????? 010 ????? 01011 11", amomaxu_w, R);
        INSTPAT("10000?? ????? ????? 011 ????? 01011 11", amomin_d, R);
        INSTPAT("10000?? ????? ????? 010 ????? 01011 11", amomin_w, R);
        INSTPAT("11000?? ????? ????? 011 ????? 01011 11", amominu_d, R);
        INSTPAT("11000?? ????? ????? 010 ????? 01011 11", amominu_w, R);
        INSTPAT("00001?? ????? ????? 011 ????? 01011 11", amoswap_d, R);
        INSTPAT("00001?? ????? ????? 010 ????? 01011 11", amoswap_w, R);

        // RV64F instructions
        INSTPAT("??????? ????? ????? 010 ????? 00001 11", flw, I);
        INSTPAT("??????? ????? ????? 010 ????? 01001 11", fsw, S);
        INSTPAT("0000000 ????? ????? ??? ????? 10100 11", fadd_s, R);
        INSTPAT("0000100 ????? ????? ??? ????? 10100 11", fsub_s, R);
        INSTPAT("0001000 ????? ????? ??? ????? 10100 11", fmul_s, R);
        INSTPAT("0001100 ????? ????? ??? ????? 10100 11", fdiv_s, R);
        INSTPAT("0101100 00000 ????? ??? ????? 10100 11", fsqrt_s, R);
        INSTPAT("0010000 ????? ????? 000 ????? 10100 11", fsgnj_s, R);
        INSTPAT("0010000 ????? ????? 001 ????? 10100 11", fsgnjn_s, R);
        INSTPAT("0010000 ????? ????? 010 ????? 10100 11", fsgnjx_s, R);
        INSTPAT("0010100 ????? ????? 000 ????? 10100 11", fmin_s, R);
        INSTPAT("0010100 ????? ????? 001 ????? 10100 11", fmax_s, R);
        INSTPAT("1100000 00000 ????? ??? ????? 10100 11", fcvt_w_s, R);
        INSTPAT("1100000 00001 ????? ??? ????? 10100 11", fcvt_wu_s, R);
        INSTPAT("1100000 00010 ????? ??? ????? 10100 11", fcvt_l_s, R);
        INSTPAT("1100000 00011 ????? ??? ????? 10100 11", fcvt_lu_s, R);
        INSTPAT("1101000 00000 ????? ??? ????? 10100 11", fcvt_s_w, R);
        INSTPAT("1101000 00001 ????? ??? ????? 10100 11", fcvt_s_wu, R);
        INSTPAT("1101000 00010 ????? ??? ????? 10100 11", fcvt_s_l, R);
        INSTPAT("1101000 00011 ????? ??? ????? 10100 11", fcvt_s_lu, R);
        INSTPAT("1110000 00000 ????? 000 ????? 10100 11", fmv_x_w, R);
        INSTPAT("1111000 00000 ????? 000 ????? 10100 11", fmv_w_x, R);
        INSTPAT("1110000 00000 ????? 001 ????? 10100 11", fclass_s, R);
        INSTPAT("1010000 ????? ????? 010 ????? 10100 11", feq_s, R);
        INSTPAT("1010000 ????? ????? 001 ????? 10100 11", flt_s, R);
        INSTPAT("1010000 ????? ????? 000 ????? 10100 11", fle_s, R);
        INSTPAT("?????00 ????? ????? ??? ????? 10000 11", fmadd_s, R4);
        INSTPAT("?????00 ????? ????? ??? ????? 10001 11", fmsub_s, R4);
        INSTPAT("?????00 ????? ????? ??? ????? 10010 11", fnmsub_s, R4);
        INSTPAT("?????00 ????? ????? ??? ????? 10011 11", fnmadd_s, R4);

        // RV64D instructions
        INSTPAT("??????? ????? ????? 011 ????? 00001 11", fld, I);
        INSTPAT("??????? ????? ????? 011 ????? 01001 11", fsd, S);
        INSTPAT("0000001 ????? ????? ??? ????? 10100 11", fadd_d, R);
        INSTPAT("0000101 ????? ????? ??? ????? 10100 11", fsub_d, R);
        INSTPAT("0001001 ????? ????? ??? ????? 10100 11", fmul_d, R);
        INSTPAT("0001101 ????? ????? ??? ????? 10100 11", fdiv_d, R);
        INSTPAT("0101101 00000 ????? ??? ????? 10100 11", fsqrt_d, R);
        INSTPAT("0010001 ????? ????? 000 ????? 10100 11", fsgnj_d, R);
        INSTPAT("0010001 ????? ????? 001 ????? 10100 11", fsgnjn_d, R);
        INSTPAT("0010001 ????? ????? 010 ????? 10100 11", fsgnjx_d, R);
        INSTPAT("0010101 ????? ????? 000 ????? 10100 11", fmin_d, R);
        INSTPAT("0010101 ????? ????? 001 ????? 10100 11", fmax_d, R);
        INSTPAT("1100001 00000 ????? ??? ????? 10100 11", fcvt_w_d, R);
        INSTPAT("1100001 00001 ????? ??? ????? 10100 11", fcvt_wu_d, R);
        INSTPAT("1100001 00010 ????? ??? ????? 10100 11", fcvt_l_d, R);
        INSTPAT("1100001 00011 ????? ??? ????? 10100 11", fcvt_lu_d, R);
        INSTPAT("1101001 00000 ????? ??? ????? 10100 11", fcvt_d_w, R);
        INSTPAT("1101001 00001 ????? ??? ????? 10100 11", fcvt_d_wu, R);
        INSTPAT("1101001 00010 ????? ??? ????? 10100 11", fcvt_d_l, R);
        INSTPAT("1101001 00011 ????? ??? ????? 10100 11", fcvt_d_lu, R);
        INSTPAT("0100000 00001 ????? ??? ????? 10100 11", fcvt_s_d, R);
        INSTPAT("0100001 00000 ????? ??? ????? 10100 11", fcvt_d_s, R);
        INSTPAT("1110001 00000 ????? 000 ????? 10100 11", fmv_x_d, R);
        INSTPAT("1111001 00000 ????? 000 ????? 10100 11", fmv_d_x, R);
        INSTPAT("1110001 00000 ????? 001 ????? 10100 11", fclass_d, R);
        INSTPAT("1010001 ????? ????? 010 ????? 10100 11", feq_d, R);
        INSTPAT("1010001 ????? ????? 001 ????? 10100 11", flt_d, R);
        INSTPAT("1010001 ????? ????? 000 ????? 10100 11", fle_d, R);
        INSTPAT("?????01 ????? ????? ??? ????? 10000 11", fmadd_d, R4);
        INSTPAT("?????01 ????? ????? ??? ????? 10001 11", fmsub_d, R4);
        INSTPAT("?????01 ????? ????? ??? ????? 10010 11", fnmsub_d, R4);
        INSTPAT("?????01 ????? ????? ??? ????? 10011 11", fnmadd_d, R4);

        // Invalid instructions
        INSTPAT("??????? ????? ????? ??? ????? ????? ??", inv, N);

#undef INSTPAT
    } else if (len == Ilen::Compressed) {

#define INSTPAT(pattern, name, itype)                                          \
    do {                                                                       \
        constexpr auto pat = parse_pattern(pattern);                           \
        if (((static_cast<uint64_t>(insn)) >> pat.shift & pat.mask) ==         \
            pat.key) {                                                         \
            s.iname = Iname::rv_##name;                                        \
            s.type = Itype::itype;                                             \
            s.exec = exec_##name;                                              \
            Decoder::decode_operand_16(s);                                     \
            return s;                                                          \
        }                                                                      \
    } while (0)

        // RV64C instructions
        INSTPAT("000 ?00000????? 01", c_nop, CI);
        INSTPAT("000 ??????????? 01", c_addi, CI);
        INSTPAT("001 ??????????? 01", c_addiw, CI);
        INSTPAT("010 ??????????? 01", c_li, CI);
        INSTPAT("011 ?00010????? 01", c_addi16sp, CI);
        INSTPAT("011 ??????????? 01", c_lui, CI);
        INSTPAT("100 ?00???????? 01", c_srli, CB);
        INSTPAT("100 ?01???????? 01", c_srai, CB);
        INSTPAT("100 ?10???????? 01", c_andi, CB);
        INSTPAT("100 011???00??? 01", c_sub, CA);
        INSTPAT("100 011???01??? 01", c_xor, CA);
        INSTPAT("100 011???10??? 01", c_or, CA);
        INSTPAT("100 011???11??? 01", c_and, CA);
        INSTPAT("100 111???00??? 01", c_subw, CA);
        INSTPAT("100 111???01??? 01", c_addw, CA);
        INSTPAT("101 ??????????? 01", c_j, CJ);
        INSTPAT("110 ??????????? 01", c_beqz, CB);
        INSTPAT("111 ??????????? 01", c_bnez, CB);
        INSTPAT("000 00000000000 00", c_inv, N);
        INSTPAT("000 ??????????? 00", c_addi4spn, CIW);
        INSTPAT("001 ??????????? 00", c_fld, CL);
        INSTPAT("010 ??????????? 00", c_lw, CL);
        INSTPAT("011 ??????????? 00", c_ld, CL);
        INSTPAT("101 ??????????? 00", c_fsd, CS);
        INSTPAT("110 ??????????? 00", c_sw, CS);
        INSTPAT("111 ??????????? 00", c_sd, CS);
        INSTPAT("000 ??????????? 10", c_slli, CI);
        INSTPAT("001 ??????????? 10", c_fldsp, CI);
        INSTPAT("010 ??????????? 10", c_lwsp, CI);
        INSTPAT("011 ??????????? 10", c_ldsp, CI);
        INSTPAT("100 0?????00000 10", c_jr, CR);
        INSTPAT("100 0?????????? 10", c_mv, CR);
        INSTPAT("100 10000000000 10", c_ebreak, CR);
        INSTPAT("100 1?????00000 10", c_jalr, CR);
        INSTPAT("100 1?????????? 10", c_add, CR);
        INSTPAT("101 ??????????? 10", c_fsdsp, CSS);
        INSTPAT("110 ??????????? 10", c_swsp, CSS);
        INSTPAT("111 ??????????? 10", c_sdsp, CSS);

        // Invalid instructions
        INSTPAT("??? ??????????? ??", inv, N);

#undef INSTPAT
    }

    std::unreachable();
}

void Decoder::decode_operand_32(DecodedInsn& s) {
    s.rs1 = bits(s.insn, 19, 15);
    s.rs2 = bits(s.insn, 24, 20);
    s.rs3 = bits(s.insn, 31, 27);
    s.rd = bits(s.insn, 11, 7);
    switch (s.type) {
        case Itype::I: s.imm = sext(bits(s.insn, 31, 20), 12); break;
        case Itype::U: s.imm = sext(bits(s.insn, 31, 12), 20) << 12; break;
        case Itype::S:
            s.imm = (sext(bits(s.insn, 31, 25), 7) << 5) | bits(s.insn, 11, 7);
            break;
        case Itype::J:
            s.imm =
                sext(bits(s.insn, 31, 31) << 20 | bits(s.insn, 19, 12) << 12 |
                         bits(s.insn, 20, 20) << 11 | bits(s.insn, 30, 21) << 1,
                     21);
            break;
        case Itype::B:
            s.imm =
                sext(bits(s.insn, 31, 31) << 12 | bits(s.insn, 7, 7) << 11 |
                         bits(s.insn, 30, 25) << 5 | bits(s.insn, 11, 8) << 1,
                     13);
            break;
        default: break;
    }
}

void Decoder::decode_operand_16(DecodedInsn& s) {
#define REG_C(x) ((x) + 8)

    uint32_t i = s.insn;
    uint8_t funct3, opcode;

    switch (s.type) {
        case Itype::CR:
            s.rd = s.rs1 = bits(i, 11, 7);
            s.rs2 = bits(i, 6, 2);
            break;
        case Itype::CI:
            s.rd = s.rs1 = bits(i, 11, 7);
            funct3 = bits(i, 15, 13);
            opcode = bits(i, 1, 0);
            if (opcode == 0b01) {
                if (funct3 == 0b000 || funct3 == 0b001 || funct3 == 0b010) {
                    s.imm = sext(bits(i, 12, 12) << 5 | bits(i, 6, 2), 6);
                } else if (funct3 == 0b011) {
                    if (s.rd == 2) {
                        s.imm =
                            sext(bits(i, 12, 12) << 9 | bits(i, 4, 3) << 7 |
                                     bits(i, 5, 5) << 6 | bits(i, 2, 2) << 5 |
                                     bits(i, 6, 6) << 4,
                                 10);
                    } else if (s.rd != 0) {
                        s.imm = sext(
                            bits(i, 12, 12) << 17 | bits(i, 6, 2) << 12, 18);
                    } else {
                        s.imm = sext(bits(i, 12, 12) << 5 | bits(i, 6, 2), 6);
                    }
                } else {
                    s.imm = sext(bits(i, 12, 12) << 5 | bits(i, 6, 2), 6);
                }
            } else if (opcode == 0b10) {
                if (funct3 == 0b000) { /* C.SLLI */
                    s.imm = (bits(i, 12, 12) << 5) | bits(i, 6, 2);
                } else if (funct3 == 0b010) { /* C.LWSP */
                    s.imm = bits(i, 3, 2) << 6 | bits(i, 12, 12) << 5 |
                            bits(i, 6, 4) << 2;
                } else if (funct3 == 0b011 ||
                           funct3 == 0b001) { /* C.LDSP C.FLDSP */
                    s.imm = bits(i, 4, 2) << 6 | bits(i, 12, 12) << 5 |
                            bits(i, 6, 5) << 3;
                } else {
                    s.imm = sext(bits(i, 12, 12) << 5 | bits(i, 6, 2), 6);
                }
            } else {
                s.imm = sext(bits(i, 12, 12) << 5 | bits(i, 6, 2), 6);
            }
            break;
        case Itype::CSS:
            s.rs1 = 2; // sp
            s.rs2 = bits(i, 6, 2);
            funct3 = bits(i, 15, 13);
            if (funct3 == 0b110) { // C.SWSP
                s.imm = bits(i, 8, 7) << 6 | bits(i, 12, 9) << 2;
            } else if (funct3 == 0b111 || funct3 == 0b101) { // C.SDSP C.FSDSP
                s.imm = bits(i, 9, 7) << 6 | bits(i, 12, 10) << 3;
            }
            break;
        case Itype::CIW:
            s.rd = REG_C(bits(i, 4, 2));
            s.rs1 = 2; // sp
            s.imm = bits(i, 10, 7) << 6 | bits(i, 12, 11) << 4 |
                    bits(i, 5, 5) << 3 | bits(i, 6, 6) << 2;
            break;
        case Itype::CL:
            s.rd = REG_C(bits(i, 4, 2));
            s.rs1 = REG_C(bits(i, 9, 7));
            funct3 = bits(i, 15, 13);
            if (funct3 == 0b010) {
                s.imm = (bits(i, 5, 5) << 6) | (bits(i, 12, 10) << 3) |
                        (bits(i, 6, 6) << 2);
            } else if (funct3 == 0b001 || funct3 == 0b011) {
                s.imm = (bits(i, 6, 5) << 6) | (bits(i, 12, 10) << 3);
            } else {
                std::unreachable();
            }
            break;
        case Itype::CS:
            s.rs1 = REG_C(bits(i, 9, 7));
            s.rs2 = REG_C(bits(i, 4, 2));
            funct3 = bits(i, 15, 13);
            if (funct3 == 0b110) {
                s.imm = (bits(i, 5, 5) << 6) | (bits(i, 12, 10) << 3) |
                        (bits(i, 6, 6) << 2);
            } else if (funct3 == 0b101 || funct3 == 0b111) {
                s.imm = (bits(i, 6, 5) << 6) | (bits(i, 12, 10) << 3);
            } else {
                std::unreachable();
            }
            break;
        case Itype::CA:
            s.rd = s.rs1 = REG_C(bits(i, 9, 7));
            s.rs2 = REG_C(bits(i, 4, 2));
            break;
        case Itype::CB:
            s.rd = s.rs1 = REG_C(bits(i, 9, 7));
            funct3 = bits(i, 15, 13);
            if (funct3 == 0b100) {
                uint32_t raw = (bits(i, 12, 12) << 5) | bits(i, 6, 2);
                if (bits(i, 11, 10) == 0b10)
                    s.imm = sext(raw, 6);
                else
                    s.imm = raw;
            } else {
                s.imm = sext(bits(i, 12, 12) << 8 | bits(i, 6, 5) << 6 |
                                 bits(i, 2, 2) << 5 | bits(i, 11, 10) << 3 |
                                 bits(i, 4, 3) << 1,
                             9);
            }
            break;
        case Itype::CJ:
            s.imm = sext(bits(i, 12, 12) << 11 | bits(i, 11, 11) << 4 |
                             bits(i, 10, 9) << 8 | bits(i, 8, 8) << 10 |
                             bits(i, 7, 7) << 6 | bits(i, 6, 6) << 7 |
                             bits(i, 5, 3) << 1 | bits(i, 2, 2) << 5,
                         12);
            break;
        case Itype::N: break;
        default: std::unreachable();
    }
}

} // namespace uemu::core
